

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Program Listing for File compression.c &mdash; SMAUG: Simulating Machine Learning Applications Using gem5-Aladdin</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/collapsible-lists/css/tree_view.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script src="../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> SMAUG
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Python API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../smaug.html">smaug</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nn.html">smaug.nn</a></li>
<li class="toctree-l1"><a class="reference internal" href="../math.html">smaug.math</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tensor.html">smaug.tensor</a></li>
</ul>
<p class="caption"><span class="caption-text">C++ API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="library_root.html">Library API</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">SMAUG</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Program Listing for File compression.c</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api/program_listing_file_smaug_utility_compression.c.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="program-listing-for-file-compression-c">
<span id="program-listing-file-smaug-utility-compression-c"></span><h1>Program Listing for File compression.c<a class="headerlink" href="#program-listing-for-file-compression-c" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_smaug_utility_compression.c.html#file-smaug-utility-compression-c"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">smaug/utility/compression.c</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&quot;core/nnet_fwd_defs.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;utility/compression.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;utility/utility.h&quot;</span><span class="cp"></span>

<span class="cp">#define MASK_AND_SHIFT(array, array_idx, vec_offset)                           \</span>
<span class="cp">    ((array)[array_idx] &amp; 0xf) &lt;&lt; (4 * (vec_offset))</span>

<span class="c1">// These two vectors must be of the same size.</span>
<span class="k">typedef</span> <span class="kt">float</span> <span class="n">v8fp_t</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">__vector_size__</span><span class="p">(</span><span class="n">TOTAL_VECTOR_BYTES</span><span class="p">)));</span>
<span class="k">typedef</span> <span class="kt">uint16_t</span> <span class="n">v16short_t</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">__vector_size__</span><span class="p">(</span><span class="n">TOTAL_VECTOR_BYTES</span><span class="p">)));</span>
<span class="c1">// This vector is used to manipulate the packed elements at VECTOR_SIZE</span>
<span class="c1">// granularity.</span>
<span class="k">typedef</span> <span class="kt">uint16_t</span> <span class="n">v8short_t</span>
        <span class="nf">__attribute__</span><span class="p">((</span><span class="n">__vector_size__</span><span class="p">(</span><span class="n">VECTOR_SIZE</span> <span class="o">*</span> <span class="n">PACKED_ELEMENT_SIZE</span><span class="p">)));</span>

<span class="c1">// These are used to pack and unpack half precision data.</span>
<span class="k">typedef</span> <span class="kt">float</span> <span class="n">v4fp_t</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">__vector_size__</span><span class="p">(</span><span class="n">TOTAL_VECTOR_BYTES</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)));</span>
<span class="k">typedef</span> <span class="kt">uint16_t</span> <span class="n">v4short_t</span>
        <span class="nf">__attribute__</span><span class="p">((</span><span class="n">__vector_size__</span><span class="p">(</span><span class="n">VECTOR_SIZE</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">PACKED_ELEMENT_SIZE</span><span class="p">)));</span>

<span class="n">csr_array_t</span><span class="o">*</span> <span class="nf">alloc_csr_array_t</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">num_nonzeros</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">num_rows</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">csr_array_t</span><span class="o">*</span> <span class="n">csr</span> <span class="o">=</span> <span class="p">(</span><span class="n">csr_array_t</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">csr_array_t</span><span class="p">));</span>
    <span class="n">csr</span><span class="o">-&gt;</span><span class="n">vals</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">malloc_aligned</span><span class="p">(</span><span class="n">num_nonzeros</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
    <span class="n">csr</span><span class="o">-&gt;</span><span class="n">col_idx</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc_aligned</span><span class="p">(</span><span class="n">num_nonzeros</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="n">csr</span><span class="o">-&gt;</span><span class="n">row_idx</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc_aligned</span><span class="p">((</span><span class="n">num_rows</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="n">csr</span><span class="o">-&gt;</span><span class="n">num_nonzeros</span> <span class="o">=</span> <span class="n">num_nonzeros</span><span class="p">;</span>
    <span class="n">csr</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">=</span> <span class="n">num_rows</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">csr</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">csr_array_t</span><span class="o">*</span> <span class="nf">copy_csr_array_t</span><span class="p">(</span><span class="n">csr_array_t</span><span class="o">*</span> <span class="n">existing_array</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">csr_array_t</span><span class="o">*</span> <span class="n">csr</span> <span class="o">=</span> <span class="n">alloc_csr_array_t</span><span class="p">(</span>
            <span class="n">existing_array</span><span class="o">-&gt;</span><span class="n">num_nonzeros</span><span class="p">,</span> <span class="n">existing_array</span><span class="o">-&gt;</span><span class="n">num_rows</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">csr</span><span class="o">-&gt;</span><span class="n">vals</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">existing_array</span><span class="o">-&gt;</span><span class="n">vals</span><span class="p">,</span>
           <span class="n">existing_array</span><span class="o">-&gt;</span><span class="n">num_nonzeros</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
    <span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">csr</span><span class="o">-&gt;</span><span class="n">col_idx</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">existing_array</span><span class="o">-&gt;</span><span class="n">col_idx</span><span class="p">,</span>
           <span class="n">existing_array</span><span class="o">-&gt;</span><span class="n">num_nonzeros</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">csr</span><span class="o">-&gt;</span><span class="n">row_idx</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">existing_array</span><span class="o">-&gt;</span><span class="n">row_idx</span><span class="p">,</span>
           <span class="p">(</span><span class="n">existing_array</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="n">csr</span><span class="o">-&gt;</span><span class="n">num_nonzeros</span> <span class="o">=</span> <span class="n">existing_array</span><span class="o">-&gt;</span><span class="n">num_nonzeros</span><span class="p">;</span>
    <span class="n">csr</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">=</span> <span class="n">existing_array</span><span class="o">-&gt;</span><span class="n">num_rows</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">csr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">print_csr_array_t</span><span class="p">(</span><span class="n">csr_array_t</span><span class="o">*</span> <span class="n">csr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Data: %lu elements</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">csr</span><span class="o">-&gt;</span><span class="n">num_nonzeros</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">csr</span><span class="o">-&gt;</span><span class="n">num_nonzeros</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%2.8f, &quot;</span><span class="p">,</span> <span class="n">csr</span><span class="o">-&gt;</span><span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Column indices: &quot;</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">csr</span><span class="o">-&gt;</span><span class="n">num_nonzeros</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d, &quot;</span><span class="p">,</span> <span class="n">csr</span><span class="o">-&gt;</span><span class="n">col_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Row indices: &quot;</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">csr</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d, &quot;</span><span class="p">,</span> <span class="n">csr</span><span class="o">-&gt;</span><span class="n">row_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">free_csr_array_t</span><span class="p">(</span><span class="n">csr_array_t</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">vals</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">col_idx</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">row_idx</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Allocate memory to store a packed CSR array.</span>
<span class="c1">//</span>
<span class="c1">// This struct needs to be accessed as a contiguous block of memory by an</span>
<span class="c1">// accelerator, so we need to allocate the memory as such. The pointers in the</span>
<span class="c1">// struct are simply referring to locations in the middle of the block.</span>
<span class="n">packed_csr_array_t</span><span class="o">*</span> <span class="nf">alloc_packed_csr_array_t</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">num_total_vectors</span><span class="p">,</span>
                                             <span class="kt">size_t</span> <span class="n">num_nonzeros</span><span class="p">,</span>
                                             <span class="kt">size_t</span> <span class="n">num_rows</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">packed_csr_array_t</span><span class="o">*</span> <span class="n">csr</span> <span class="o">=</span>
            <span class="p">(</span><span class="n">packed_csr_array_t</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">packed_csr_array_t</span><span class="p">));</span>
    <span class="kt">size_t</span> <span class="n">values_size</span> <span class="o">=</span> <span class="n">next_multiple</span><span class="p">(</span>
            <span class="n">num_total_vectors</span> <span class="o">*</span> <span class="n">TOTAL_VECTOR_BYTES</span><span class="p">,</span> <span class="n">TOTAL_VECTOR_BYTES</span><span class="p">);</span>
    <span class="kt">size_t</span> <span class="n">col_idx_size</span> <span class="o">=</span> <span class="n">next_multiple</span><span class="p">(</span>
            <span class="n">num_total_vectors</span> <span class="o">*</span> <span class="n">DATA_TO_INDEX_RATIO</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">),</span>
            <span class="n">TOTAL_VECTOR_BYTES</span><span class="p">);</span>
    <span class="kt">size_t</span> <span class="n">row_idx_size</span> <span class="o">=</span>
            <span class="n">next_multiple</span><span class="p">(</span><span class="n">num_rows</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">),</span> <span class="n">TOTAL_VECTOR_BYTES</span><span class="p">);</span>
    <span class="kt">size_t</span> <span class="n">total_buf_size</span> <span class="o">=</span> <span class="n">values_size</span> <span class="o">+</span> <span class="n">col_idx_size</span> <span class="o">+</span> <span class="n">row_idx_size</span><span class="p">;</span>
    <span class="kt">uint32_t</span><span class="o">*</span> <span class="n">buffer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)</span><span class="n">malloc_aligned</span><span class="p">(</span><span class="n">total_buf_size</span><span class="p">);</span>
    <span class="n">csr</span><span class="o">-&gt;</span><span class="n">vals</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
    <span class="n">csr</span><span class="o">-&gt;</span><span class="n">col_idx</span> <span class="o">=</span> <span class="n">csr</span><span class="o">-&gt;</span><span class="n">vals</span> <span class="o">+</span> <span class="n">values_size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
    <span class="n">csr</span><span class="o">-&gt;</span><span class="n">row_idx</span> <span class="o">=</span> <span class="n">csr</span><span class="o">-&gt;</span><span class="n">col_idx</span> <span class="o">+</span> <span class="n">col_idx_size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
    <span class="n">csr</span><span class="o">-&gt;</span><span class="n">num_nonzeros</span> <span class="o">=</span> <span class="n">num_nonzeros</span><span class="p">;</span>
    <span class="n">csr</span><span class="o">-&gt;</span><span class="n">num_total_vectors</span> <span class="o">=</span> <span class="n">num_total_vectors</span><span class="p">;</span>
    <span class="n">csr</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">=</span> <span class="n">num_rows</span><span class="p">;</span>
    <span class="n">csr</span><span class="o">-&gt;</span><span class="n">total_buf_size</span> <span class="o">=</span> <span class="n">total_buf_size</span><span class="p">;</span>  <span class="c1">// Used for setting TLB mappings.</span>
    <span class="k">return</span> <span class="n">csr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Copy an existing packed CSR array into a new array.</span>
<span class="cm"> *</span>
<span class="cm"> * This fully duplicates the data and all the pointers and metadata.</span>
<span class="cm"> */</span>
<span class="n">packed_csr_array_t</span><span class="o">*</span> <span class="nf">copy_packed_csr_array_t</span><span class="p">(</span><span class="n">packed_csr_array_t</span><span class="o">*</span> <span class="n">existing_array</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">packed_csr_array_t</span><span class="o">*</span> <span class="n">csr</span> <span class="o">=</span> <span class="n">alloc_packed_csr_array_t</span><span class="p">(</span>
            <span class="n">existing_array</span><span class="o">-&gt;</span><span class="n">num_total_vectors</span><span class="p">,</span> <span class="n">existing_array</span><span class="o">-&gt;</span><span class="n">num_nonzeros</span><span class="p">,</span>
            <span class="n">existing_array</span><span class="o">-&gt;</span><span class="n">num_rows</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">csr</span><span class="o">-&gt;</span><span class="n">vals</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">existing_array</span><span class="o">-&gt;</span><span class="n">vals</span><span class="p">,</span>
           <span class="n">existing_array</span><span class="o">-&gt;</span><span class="n">total_buf_size</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">csr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">free_packed_csr_array_t</span><span class="p">(</span><span class="n">packed_csr_array_t</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// There was only one memory allocation required for the entire struct.</span>
    <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">vals</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">compute_num_vectors_in_row</span><span class="p">(</span><span class="kt">int</span> <span class="n">num_elems_in_row</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">FRAC_CEIL</span><span class="p">(</span><span class="n">num_elems_in_row</span><span class="p">,</span> <span class="n">DATA_PACKING_FACTOR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Compress an array of single-precision FP values to half precision.</span>
<span class="cm"> *</span>
<span class="cm"> * This does not perform CSR compression; it only performs precision reduction.</span>
<span class="cm"> * There are no requirements on the size of the FP array. Two FP values are</span>
<span class="cm"> * packed into a 32-bit value, with the first occupying bits 0-15 and the</span>
<span class="cm"> * second from 16-31.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a pointer to a malloc&#39;ed fp16array_t object, whose size is equal to the</span>
<span class="cm"> * minimum number of 32-bit unsigned values required to store the packed data.</span>
<span class="cm"> * To use an existing buffer, pass its pointer to the dest_buf argument;</span>
<span class="cm"> * otherwise, pass NULL, and it will be autmoatically allocated.</span>
<span class="cm"> *</span>
<span class="cm"> * TODO: Make dest_buf a fp16array_t* pointer instead, so we don&#39;t have to</span>
<span class="cm"> * worry about memory leaks when we replace an existing fp16array_t object.</span>
<span class="cm"> */</span>
<span class="n">fp16array_t</span><span class="o">*</span> <span class="nf">pack_data_fp16</span><span class="p">(</span><span class="n">farray_t</span><span class="o">*</span> <span class="n">sp_data</span><span class="p">,</span> <span class="n">packed_fp16</span><span class="o">*</span> <span class="n">dest_buf</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fp16array_t</span><span class="o">*</span> <span class="n">hp_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">fp16array_t</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">fp16array_t</span><span class="p">));</span>
    <span class="n">hp_data</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">sp_data</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">sp_data</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">%</span> <span class="mi">2</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dest_buf</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">hp_data</span><span class="o">-&gt;</span><span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">packed_fp16</span><span class="o">*</span><span class="p">)</span><span class="n">malloc_aligned</span><span class="p">(</span><span class="n">hp_data</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">*</span>
                                                  <span class="k">sizeof</span><span class="p">(</span><span class="n">packed_fp16</span><span class="p">));</span>
        <span class="n">hp_data</span><span class="o">-&gt;</span><span class="n">freeable</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">hp_data</span><span class="o">-&gt;</span><span class="n">d</span> <span class="o">=</span> <span class="n">dest_buf</span><span class="p">;</span>
        <span class="n">hp_data</span><span class="o">-&gt;</span><span class="n">freeable</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">hp_data</span><span class="o">-&gt;</span><span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
           <span class="n">next_multiple</span><span class="p">(</span><span class="n">hp_data</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">packed_fp16</span><span class="p">),</span> <span class="n">CACHELINE_SIZE</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sp_data</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">bool</span> <span class="n">use_lo_half</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">hp_data</span><span class="o">-&gt;</span><span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">|=</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">_CVT_SS_SH</span><span class="p">(</span><span class="n">sp_data</span><span class="o">-&gt;</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">))</span>
                             <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">use_lo_half</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">16</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">hp_data</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Decompress an array of half-precision FP values to single precision.</span>
<span class="cm"> *</span>
<span class="cm"> * This requires that the number of packed elements be a multiple of 4, so that</span>
<span class="cm"> * it can use 128-bit F16C instructions to efficiently unpack 4 values at a</span>
<span class="cm"> * time.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a pointer to a malloc&#39;ed farray_t object holding the decompressed</span>
<span class="cm"> * data.  To use an existing buffer, pass its pointer to the dest_buf argument;</span>
<span class="cm"> * otherwise, pass NULL, and it will be autmoatically allocated.</span>
<span class="cm"> */</span>
<span class="n">farray_t</span><span class="o">*</span> <span class="nf">unpack_data_fp16x4</span><span class="p">(</span><span class="n">fp16array_t</span><span class="o">*</span> <span class="n">hp_data</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">dest_buf</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">hp_data</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
           <span class="s">&quot;Half precision data size of must be a multiple of 4!&quot;</span><span class="p">);</span>
    <span class="n">farray_t</span><span class="o">*</span> <span class="n">sp_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">farray_t</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">farray_t</span><span class="p">));</span>
    <span class="n">sp_data</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">hp_data</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dest_buf</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sp_data</span><span class="o">-&gt;</span><span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">malloc_aligned</span><span class="p">(</span><span class="n">sp_data</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
        <span class="n">sp_data</span><span class="o">-&gt;</span><span class="n">freeable</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">sp_data</span><span class="o">-&gt;</span><span class="n">d</span> <span class="o">=</span> <span class="n">dest_buf</span><span class="p">;</span>
        <span class="n">sp_data</span><span class="o">-&gt;</span><span class="n">freeable</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">sp_data</span><span class="o">-&gt;</span><span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
           <span class="n">next_multiple</span><span class="p">(</span><span class="n">sp_data</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="n">CACHELINE_SIZE</span><span class="p">));</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hp_data</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">v8short_t</span> <span class="n">packed_data</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">v8short_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">hp_data</span><span class="o">-&gt;</span><span class="n">d</span><span class="p">[</span><span class="mi">4</span> <span class="o">*</span> <span class="n">i</span><span class="p">];</span>
        <span class="n">v8short_t</span> <span class="n">packed_data_hi</span> <span class="o">=</span>
                <span class="p">(</span><span class="n">v8short_t</span><span class="p">)</span><span class="n">_SHUFFLE_PD</span><span class="p">(</span><span class="n">packed_data</span><span class="p">,</span> <span class="n">packed_data</span><span class="p">,</span> <span class="mh">0x3</span><span class="p">);</span>
        <span class="o">*</span><span class="p">((</span><span class="n">v4fp_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sp_data</span><span class="o">-&gt;</span><span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">8</span><span class="p">])</span> <span class="o">=</span> <span class="p">(</span><span class="n">v4fp_t</span><span class="p">)</span><span class="n">_CVT_PH_PS_128</span><span class="p">(</span><span class="n">packed_data</span><span class="p">);</span>
        <span class="o">*</span><span class="p">((</span><span class="n">v4fp_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sp_data</span><span class="o">-&gt;</span><span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">+</span> <span class="mi">4</span><span class="p">])</span> <span class="o">=</span>
                <span class="p">(</span><span class="n">v4fp_t</span><span class="p">)</span><span class="n">_CVT_PH_PS_128</span><span class="p">(</span><span class="n">packed_data_hi</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">sp_data</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Compress an uncompressed matrix into the modified CSR format.</span>
<span class="cm"> *</span>
<span class="cm"> * The modified CSR format is based on the CSC format used in Deep</span>
<span class="cm"> * Compression (Han et al):</span>
<span class="cm"> *   1. The nonzero values are stored linearly.</span>
<span class="cm"> *   2. Indices are the relative offsets from the previous value to the</span>
<span class="cm"> *      next nonzero value position. They are represented as 4-bit values,</span>
<span class="cm"> *      so if any two nonzero values are spaced 16 columns or more apart,</span>
<span class="cm"> *      a padding zero is inserted into the data array with offset 15.</span>
<span class="cm"> *   3. Row indices are stored in unmodified CSR format. The value is equal to</span>
<span class="cm"> *      the sum of the number of nonzero values and padding zeros in this row.</span>
<span class="cm"> *      There is no additional zero padding added at the end of the row.</span>
<span class="cm"> *   4. Native types are used - float for the data, int for column and row</span>
<span class="cm"> *      indices.</span>
<span class="cm"> */</span>
<span class="n">csr_array_t</span><span class="o">*</span> <span class="nf">compress_dense_data_csr</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="n">dims_t</span><span class="o">*</span> <span class="n">data_dims</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">num_values</span> <span class="o">=</span> <span class="n">get_dims_size</span><span class="p">(</span><span class="n">data_dims</span><span class="p">);</span>
    <span class="c1">// First we&#39;ll allocate space for the complete dense array; later, once</span>
    <span class="c1">// we&#39;ve completely compressed the array, we&#39;ll copy it into a new smaller</span>
    <span class="c1">// sparse array. This is because due to the limited bitwidth for relative</span>
    <span class="c1">// offsets, we don&#39;t know how much internal zero padding is needed.</span>
    <span class="n">csr_array_t</span><span class="o">*</span> <span class="n">csr</span> <span class="o">=</span> <span class="n">alloc_csr_array_t</span><span class="p">(</span><span class="n">num_values</span><span class="p">,</span> <span class="n">data_dims</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">);</span>
    <span class="n">ARRAY_3D</span><span class="p">(</span><span class="kt">float</span><span class="p">,</span> <span class="n">_data</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">data_dims</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">,</span> <span class="n">data_dims</span><span class="o">-&gt;</span><span class="n">cols</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">num_nonzeros</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">curr_row_idx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">data_dims</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span> <span class="n">h</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">data_dims</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">;</span> <span class="n">r</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">PRINT_MSG_V</span><span class="p">(</span><span class="s">&quot;Row %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
            <span class="c1">// First, count the total number of nonzeros in this row.</span>
            <span class="kt">int</span> <span class="n">num_elems_in_row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">last_nz_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">data_dims</span><span class="o">-&gt;</span><span class="n">cols</span><span class="p">;</span> <span class="n">c</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">_data</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">num_elems_in_row</span><span class="o">++</span><span class="p">;</span>
                    <span class="n">last_nz_idx</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">PRINT_MSG_V</span><span class="p">(</span><span class="s">&quot;  Number of non zeros: %d, last idx: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                        <span class="n">num_elems_in_row</span><span class="p">,</span>
                        <span class="n">last_nz_idx</span><span class="p">);</span>

            <span class="kt">int</span> <span class="n">next_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="n">last_nz_idx</span><span class="p">;</span> <span class="n">c</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">float</span> <span class="n">curr_value</span> <span class="o">=</span> <span class="n">_data</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">];</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">curr_value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="n">next_offset</span><span class="o">++</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">curr_value</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">next_offset</span> <span class="o">==</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">next_offset</span> <span class="o">==</span> <span class="mi">16</span><span class="p">)</span>
                        <span class="n">next_offset</span><span class="o">--</span><span class="p">;</span>
                    <span class="n">csr</span><span class="o">-&gt;</span><span class="n">vals</span><span class="p">[</span><span class="n">num_nonzeros</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_value</span><span class="p">;</span>
                    <span class="n">csr</span><span class="o">-&gt;</span><span class="n">col_idx</span><span class="p">[</span><span class="n">num_nonzeros</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_offset</span><span class="p">;</span>
                    <span class="n">PRINT_MSG_V</span><span class="p">(</span><span class="s">&quot; Writing %5.5f, %d at index %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                                <span class="n">curr_value</span><span class="p">,</span>
                                <span class="n">next_offset</span><span class="p">,</span>
                                <span class="n">num_nonzeros</span><span class="p">);</span>
                    <span class="n">num_nonzeros</span><span class="o">++</span><span class="p">;</span>
                    <span class="n">next_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">csr</span><span class="o">-&gt;</span><span class="n">row_idx</span><span class="p">[</span><span class="n">curr_row_idx</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_nonzeros</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">csr</span><span class="o">-&gt;</span><span class="n">num_nonzeros</span> <span class="o">=</span> <span class="n">num_nonzeros</span><span class="p">;</span>
    <span class="n">csr</span><span class="o">-&gt;</span><span class="n">row_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// Copy the data to a new sparse array and free the current one.</span>
    <span class="n">csr_array_t</span><span class="o">*</span> <span class="n">result</span> <span class="o">=</span> <span class="n">copy_csr_array_t</span><span class="p">(</span><span class="n">csr</span><span class="p">);</span>
    <span class="n">free_csr_array_t</span><span class="p">(</span><span class="n">csr</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Pack data in the modified CSR format into a more compact storage format.</span>
<span class="cm"> *</span>
<span class="cm"> * The packed, quantized format looks like:</span>
<span class="cm"> *   1. Each value is compressed to 16 bit half precision floating point.</span>
<span class="cm"> *   2. 16 FP16 values are packed into 32-byte vectors.</span>
<span class="cm"> *   3. New rows always start on vector-aligned addresses; they cannot</span>
<span class="cm"> *      cross vector boundaries.</span>
<span class="cm"> *   4. 8 4-bit integer offsets are packed into 32-bit integers.</span>
<span class="cm"> *   5. Each row index is represented as a 32-bit packed pair of values.</span>
<span class="cm"> *      a. Bits 0-15: The number of elements in this row.</span>
<span class="cm"> *      b. Bits 16-31: The vector index in the data array that marks the</span>
<span class="cm"> *         beginning of this row.</span>
<span class="cm"> */</span>
<span class="n">packed_csr_array_t</span><span class="o">*</span> <span class="nf">pack_csr_array_vec8_f16</span><span class="p">(</span><span class="n">csr_array_t</span><span class="o">*</span> <span class="n">csr_data</span><span class="p">,</span>
                                            <span class="n">dims_t</span><span class="o">*</span> <span class="n">data_dims</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">PRINT_MSG_V</span><span class="p">(</span><span class="s">&quot;==== COMPRESSING ===== </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="c1">// First, compute the overall size of the packed data, accounting for</span>
    <span class="c1">// row-alignment requirements.</span>
    <span class="kt">size_t</span> <span class="n">total_num_vectors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">data_dims</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">total_num_vectors</span> <span class="o">+=</span> <span class="n">compute_num_vectors_in_row</span><span class="p">(</span>
                <span class="n">csr_data</span><span class="o">-&gt;</span><span class="n">row_idx</span><span class="p">[</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">csr_data</span><span class="o">-&gt;</span><span class="n">row_idx</span><span class="p">[</span><span class="n">row</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">PRINT_MSG_V</span><span class="p">(</span><span class="s">&quot;total num vectors: %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">total_num_vectors</span><span class="p">);</span>

    <span class="n">packed_csr_array_t</span><span class="o">*</span> <span class="n">csr</span> <span class="o">=</span> <span class="n">alloc_packed_csr_array_t</span><span class="p">(</span>
            <span class="n">total_num_vectors</span><span class="p">,</span> <span class="n">csr_data</span><span class="o">-&gt;</span><span class="n">num_nonzeros</span><span class="p">,</span> <span class="n">data_dims</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">);</span>

    <span class="n">v16short_t</span><span class="o">*</span> <span class="n">_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">v16short_t</span><span class="o">*</span><span class="p">)</span><span class="n">csr</span><span class="o">-&gt;</span><span class="n">vals</span><span class="p">;</span>
    <span class="c1">// Independently track the current linear index into the compressed data</span>
    <span class="c1">// column, and row indices arrays.</span>
    <span class="kt">int</span> <span class="n">curr_wgt_src_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">curr_wgt_dst_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">curr_col_src_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">curr_col_dst_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">curr_packed_row_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// Track the number of elements we&#39;ve packed, so we can sanity check to</span>
    <span class="c1">// make sure we never exceed num_nonzero.</span>
    <span class="kt">unsigned</span> <span class="n">total_elements_packed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">data_dims</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">row_start_idx</span> <span class="o">=</span> <span class="n">csr_data</span><span class="o">-&gt;</span><span class="n">row_idx</span><span class="p">[</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">num_elems_in_row</span> <span class="o">=</span> <span class="n">row_start_idx</span> <span class="o">-</span> <span class="n">csr_data</span><span class="o">-&gt;</span><span class="n">row_idx</span><span class="p">[</span><span class="n">row</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">num_packed_data_vectors</span> <span class="o">=</span>
                <span class="n">FRAC_CEIL</span><span class="p">(</span><span class="n">num_elems_in_row</span><span class="p">,</span> <span class="n">VECTOR_SIZE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
        <span class="n">PRINT_MSG_V</span><span class="p">(</span><span class="s">&quot;Row = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">row</span><span class="p">);</span>
        <span class="n">PRINT_MSG_V</span><span class="p">(</span><span class="s">&quot;  row start idx %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">row_start_idx</span><span class="p">);</span>
        <span class="n">PRINT_MSG_V</span><span class="p">(</span><span class="s">&quot;  num elements in row %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">num_elems_in_row</span><span class="p">);</span>
        <span class="n">PRINT_MSG_V</span><span class="p">(</span><span class="s">&quot;  num packed vectors %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">num_packed_data_vectors</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">elems_remaining</span> <span class="o">=</span> <span class="n">num_elems_in_row</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">vec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">vec</span> <span class="o">&lt;</span> <span class="n">num_packed_data_vectors</span><span class="p">;</span> <span class="n">vec</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">v8fp_t</span> <span class="n">data_f32</span> <span class="o">=</span> <span class="p">(</span><span class="n">v8fp_t</span><span class="p">){</span> <span class="mi">0</span> <span class="p">};</span>
            <span class="n">v16short_t</span> <span class="n">data_f16</span> <span class="o">=</span> <span class="p">(</span><span class="n">v16short_t</span><span class="p">){</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                                <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>
            <span class="c1">// We can only pack up to 8 SP floats at once, but the size of the</span>
            <span class="c1">// vector containing the packed data that we will eventually read</span>
            <span class="c1">// out is the same size in bytes as the uncompressed, so multiple</span>
            <span class="c1">// iterations are needed to thoroughly pack all possible elements</span>
            <span class="c1">// into the vector.</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">iter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                 <span class="n">iter</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">UNPACKED_ELEMENT_SIZE</span> <span class="o">/</span> <span class="n">PACKED_ELEMENT_SIZE</span><span class="p">);</span>
                 <span class="n">iter</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">elems_remaining</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">min2</span><span class="p">(</span><span class="n">elems_remaining</span><span class="p">,</span> <span class="n">VECTOR_SIZE</span><span class="p">);</span>
                     <span class="n">col</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">data_f32</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">csr_data</span><span class="o">-&gt;</span><span class="n">vals</span><span class="p">[</span><span class="n">curr_wgt_src_idx</span><span class="o">++</span><span class="p">];</span>
                <span class="p">}</span>
                <span class="n">v8short_t</span> <span class="n">packed_f16</span> <span class="o">=</span> <span class="n">_CVT_PS_PH_256</span><span class="p">(</span><span class="n">data_f32</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">VECTOR_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">PRINT_MSG_V</span><span class="p">(</span><span class="s">&quot;  packed data: %#4x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">packed_f16</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                    <span class="n">data_f16</span><span class="p">[</span><span class="n">iter</span> <span class="o">*</span> <span class="n">VECTOR_SIZE</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">packed_f16</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="p">}</span>

                <span class="n">elems_remaining</span> <span class="o">-=</span> <span class="n">VECTOR_SIZE</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">PRINT_MSG_V</span><span class="p">(</span><span class="s">&quot;  Storing to data[%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">curr_wgt_dst_idx</span><span class="p">);</span>
            <span class="n">_data</span><span class="p">[</span><span class="n">curr_wgt_dst_idx</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_f16</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 4 bit indices -&gt; 8 per 32-bit integer. They are indexed like so:</span>
        <span class="c1">// | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |</span>
        <span class="c1">// which means that if there are only two indices remaining in this</span>
        <span class="c1">// row, then they will be aligned towards the right 8 bits of the</span>
        <span class="c1">// 32-bit value.</span>
        <span class="c1">//</span>
        <span class="c1">// TODO: Column indices can straddle vector boundaries!!!! This is not</span>
        <span class="c1">// good!!!</span>
        <span class="n">elems_remaining</span> <span class="o">=</span> <span class="n">num_elems_in_row</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">num_packed_idx_vectors</span> <span class="o">=</span>
                <span class="n">num_packed_data_vectors</span> <span class="o">*</span> <span class="n">DATA_TO_INDEX_RATIO</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">vec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">vec</span> <span class="o">&lt;</span> <span class="n">num_packed_idx_vectors</span><span class="p">;</span> <span class="n">vec</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">csr</span><span class="o">-&gt;</span><span class="n">col_idx</span><span class="p">[</span><span class="n">curr_col_dst_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">elem</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                 <span class="n">elem</span> <span class="o">&lt;</span> <span class="n">min2</span><span class="p">(</span><span class="n">elems_remaining</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">INDEX_PACKING_FACTOR</span><span class="p">);</span>
                 <span class="n">elem</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">csr</span><span class="o">-&gt;</span><span class="n">col_idx</span><span class="p">[</span><span class="n">curr_col_dst_idx</span><span class="p">]</span> <span class="o">|=</span> <span class="n">MASK_AND_SHIFT</span><span class="p">(</span>
                        <span class="n">csr_data</span><span class="o">-&gt;</span><span class="n">col_idx</span><span class="p">,</span> <span class="n">curr_col_src_idx</span><span class="o">++</span><span class="p">,</span> <span class="n">elem</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">PRINT_MSG_V</span><span class="p">(</span><span class="s">&quot;  packed col_idx[%d] = %#x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                        <span class="n">curr_col_dst_idx</span><span class="p">,</span>
                        <span class="n">csr</span><span class="o">-&gt;</span><span class="n">col_idx</span><span class="p">[</span><span class="n">curr_col_dst_idx</span><span class="p">]);</span>
            <span class="n">elems_remaining</span> <span class="o">-=</span> <span class="n">INDEX_PACKING_FACTOR</span><span class="p">;</span>
            <span class="n">curr_col_dst_idx</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">csr</span><span class="o">-&gt;</span><span class="n">row_idx</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span>
                <span class="n">create_packed_row</span><span class="p">(</span><span class="n">curr_packed_row_idx</span><span class="p">,</span> <span class="n">num_elems_in_row</span><span class="p">);</span>
        <span class="n">curr_packed_row_idx</span> <span class="o">+=</span> <span class="n">num_packed_data_vectors</span><span class="p">;</span>
        <span class="n">PRINT_MSG_V</span><span class="p">(</span><span class="s">&quot;  packed row = %#x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">csr</span><span class="o">-&gt;</span><span class="n">row_idx</span><span class="p">[</span><span class="n">row</span><span class="p">]);</span>
        <span class="n">total_elements_packed</span> <span class="o">+=</span> <span class="n">num_elems_in_row</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">total_elements_packed</span> <span class="o">==</span> <span class="n">csr_data</span><span class="o">-&gt;</span><span class="n">num_nonzeros</span> <span class="o">&amp;&amp;</span>
           <span class="s">&quot;The number of packed elements is not the same as the number of non &quot;</span>
           <span class="s">&quot;zero elements specified!&quot;</span><span class="p">);</span>

    <span class="n">PRINT_MSG_V</span><span class="p">(</span><span class="s">&quot;Compressed data:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">total_num_vectors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">PRINT_MSG_V</span><span class="p">(</span><span class="s">&quot;%#x &quot;</span><span class="p">,</span> <span class="n">csr</span><span class="o">-&gt;</span><span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">PRINT_MSG_V</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Compressed col indices:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">total_num_vectors</span> <span class="o">*</span> <span class="n">DATA_TO_INDEX_RATIO</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">PRINT_MSG_V</span><span class="p">(</span><span class="s">&quot;%#x &quot;</span><span class="p">,</span> <span class="n">csr</span><span class="o">-&gt;</span><span class="n">col_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">PRINT_MSG_V</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Compressed row indices:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">data_dims</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">PRINT_MSG_V</span><span class="p">(</span><span class="s">&quot;%#x &quot;</span><span class="p">,</span> <span class="n">csr</span><span class="o">-&gt;</span><span class="n">row_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">PRINT_MSG_V</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">csr</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Decompress data in unpacked modified CSR format.</span>
<span class="kt">void</span> <span class="nf">decompress_csr_data</span><span class="p">(</span><span class="n">csr_array_t</span><span class="o">*</span> <span class="n">csr_data</span><span class="p">,</span>
                         <span class="n">dims_t</span><span class="o">*</span> <span class="n">data_dims</span><span class="p">,</span>
                         <span class="kt">float</span><span class="o">*</span> <span class="n">dcmp_data</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">data_rows</span> <span class="o">=</span> <span class="n">data_dims</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">data_cols</span> <span class="o">=</span> <span class="n">data_dims</span><span class="o">-&gt;</span><span class="n">cols</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">data_pad</span> <span class="o">=</span> <span class="n">data_dims</span><span class="o">-&gt;</span><span class="n">align_pad</span><span class="p">;</span>

    <span class="n">ARRAY_2D</span><span class="p">(</span><span class="kt">float</span><span class="p">,</span> <span class="n">_data</span><span class="p">,</span> <span class="n">dcmp_data</span><span class="p">,</span> <span class="n">data_cols</span> <span class="o">+</span> <span class="n">data_pad</span><span class="p">);</span>
    <span class="n">PRINT_MSG_V</span><span class="p">(</span><span class="s">&quot;==== DECOMPRESSING ==== </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">curr_col_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">data_rows</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">curr_row_start_idx</span> <span class="o">=</span> <span class="n">csr_data</span><span class="o">-&gt;</span><span class="n">row_idx</span><span class="p">[</span><span class="n">row</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">next_row_start_idx</span> <span class="o">=</span> <span class="n">csr_data</span><span class="o">-&gt;</span><span class="n">row_idx</span><span class="p">[</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">num_elems_in_row</span> <span class="o">=</span> <span class="n">next_row_start_idx</span> <span class="o">-</span> <span class="n">curr_row_start_idx</span><span class="p">;</span>
        <span class="n">PRINT_MSG_V</span><span class="p">(</span><span class="s">&quot;Row %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">row</span><span class="p">);</span>
        <span class="n">PRINT_MSG_V</span><span class="p">(</span><span class="s">&quot;  Row start idx: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">curr_row_start_idx</span><span class="p">);</span>
        <span class="n">PRINT_MSG_V</span><span class="p">(</span><span class="s">&quot;  Row size: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">num_elems_in_row</span><span class="p">);</span>

        <span class="c1">// A column index of zero means there are no zeros in between it and</span>
        <span class="c1">// the previous nonzero value.  So, we need to implicitly add 1 to the</span>
        <span class="c1">// existing offset to get the new decompressed column index. This</span>
        <span class="c1">// boundary condition is easily handled with a starting offset of -1.</span>
        <span class="kt">int</span> <span class="n">col_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">num_elems_in_row</span><span class="p">;</span> <span class="n">col</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">col_idx</span> <span class="o">+=</span> <span class="n">csr_data</span><span class="o">-&gt;</span><span class="n">col_idx</span><span class="p">[</span><span class="n">curr_col_idx</span><span class="p">];</span>
            <span class="n">ASSERT</span><span class="p">(</span><span class="n">col_idx</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">data_cols</span> <span class="o">+</span> <span class="n">data_pad</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                   <span class="s">&quot;Column index exceeds width of matrix!&quot;</span><span class="p">);</span>
            <span class="kt">float</span> <span class="n">value</span> <span class="o">=</span> <span class="n">csr_data</span><span class="o">-&gt;</span><span class="n">vals</span><span class="p">[</span><span class="n">curr_col_idx</span><span class="p">];</span>
            <span class="n">_data</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
            <span class="n">curr_col_idx</span><span class="o">++</span><span class="p">;</span>
            <span class="n">col_idx</span><span class="o">++</span><span class="p">;</span>
            <span class="n">PRINT_MSG_V</span><span class="p">(</span><span class="s">&quot;  Storing _data[%d][%d] = %f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col_idx</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Unpack a vector&#39;s worth of CSR values and indices at a specific location.</span>
<span class="c1">//</span>
<span class="c1">// Since a vector stores 16 FP16 elements, this returns the unpacked</span>
<span class="c1">// single-precision values and indices at that location in values_buffer and</span>
<span class="c1">// index_buffer.</span>
<span class="c1">//</span>
<span class="c1">// Args:</span>
<span class="c1">//   cmp_values: A pointer to the start of the packed CSR data.</span>
<span class="c1">//   cmp_col_idx: A pointer to the start of the packed CSR column indices.</span>
<span class="c1">//   fetch_index_vec: The index of the vector to fetch from the two arrays</span>
<span class="c1">//                    above. This index refers to a VECTOR_ALIGNED memory</span>
<span class="c1">//                    address.</span>
<span class="c1">//   values_buffer: Stores up to 16 unpacked values.</span>
<span class="c1">//   index_buffer: Stores up to 16 unpacked indices.</span>
<span class="kt">void</span> <span class="nf">unpack_values_at_row</span><span class="p">(</span><span class="n">packed_fp16</span><span class="o">*</span> <span class="n">cmp_values</span><span class="p">,</span>
                          <span class="kt">uint32_t</span><span class="o">*</span> <span class="n">cmp_col_idx</span><span class="p">,</span>
                          <span class="kt">int</span> <span class="n">fetch_index_vec</span><span class="p">,</span>
                          <span class="kt">float</span> <span class="n">values_buffer</span><span class="p">[</span><span class="n">VECTOR_SIZE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">],</span>
                          <span class="kt">int</span> <span class="n">index_buffer</span><span class="p">[</span><span class="n">VECTOR_SIZE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">])</span> <span class="p">{</span>
    <span class="n">v16short_t</span><span class="o">*</span> <span class="n">_cmp_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">v16short_t</span><span class="o">*</span><span class="p">)</span><span class="n">cmp_values</span><span class="p">;</span>

    <span class="c1">// Extract and decompress the values.</span>
    <span class="n">PRINT_MSG_V</span><span class="p">(</span><span class="s">&quot;  Fetching packed values from %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fetch_index_vec</span><span class="p">);</span>
    <span class="n">v16short_t</span> <span class="n">curr_values</span> <span class="o">=</span> <span class="n">_cmp_values</span><span class="p">[</span><span class="n">fetch_index_vec</span><span class="p">];</span>

<span class="cp">#ifdef __clang__</span>
    <span class="n">v8short_t</span> <span class="n">values0_f16</span> <span class="o">=</span> <span class="n">__builtin_shufflevector</span><span class="p">(</span>
            <span class="n">curr_values</span><span class="p">,</span> <span class="n">curr_values</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
    <span class="n">v8short_t</span> <span class="n">values1_f16</span> <span class="o">=</span> <span class="n">__builtin_shufflevector</span><span class="p">(</span>
            <span class="n">curr_values</span><span class="p">,</span> <span class="n">curr_values</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">);</span>
<span class="cp">#else</span>
    <span class="n">v8short_t</span> <span class="n">values0_f16</span> <span class="o">=</span>
            <span class="p">(</span><span class="n">v8short_t</span><span class="p">){</span> <span class="n">curr_values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">curr_values</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">curr_values</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                         <span class="n">curr_values</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">curr_values</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">curr_values</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>
                         <span class="n">curr_values</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">curr_values</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="p">};</span>
    <span class="n">v8short_t</span> <span class="n">values1_f16</span> <span class="o">=</span>
            <span class="p">(</span><span class="n">v8short_t</span><span class="p">){</span> <span class="n">curr_values</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span>  <span class="n">curr_values</span><span class="p">[</span><span class="mi">9</span><span class="p">],</span>  <span class="n">curr_values</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span>
                         <span class="n">curr_values</span><span class="p">[</span><span class="mi">11</span><span class="p">],</span> <span class="n">curr_values</span><span class="p">[</span><span class="mi">12</span><span class="p">],</span> <span class="n">curr_values</span><span class="p">[</span><span class="mi">13</span><span class="p">],</span>
                         <span class="n">curr_values</span><span class="p">[</span><span class="mi">14</span><span class="p">],</span> <span class="n">curr_values</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="p">};</span>
<span class="cp">#endif</span>
    <span class="n">v8fp_t</span> <span class="n">values0_f32</span> <span class="o">=</span> <span class="n">_CVT_PH_PS_256</span><span class="p">(</span><span class="n">values0_f16</span><span class="p">);</span>
    <span class="n">v8fp_t</span> <span class="n">values1_f32</span> <span class="o">=</span> <span class="n">_CVT_PH_PS_256</span><span class="p">(</span><span class="n">values1_f16</span><span class="p">);</span>

    <span class="c1">// Extract the 4-bit compressed indices.</span>
    <span class="kt">unsigned</span> <span class="n">idx0</span> <span class="o">=</span> <span class="n">cmp_col_idx</span><span class="p">[</span><span class="n">fetch_index_vec</span> <span class="o">*</span> <span class="n">DATA_TO_INDEX_RATIO</span><span class="p">];</span>
    <span class="kt">unsigned</span> <span class="n">idx1</span> <span class="o">=</span> <span class="n">cmp_col_idx</span><span class="p">[</span><span class="n">fetch_index_vec</span> <span class="o">*</span> <span class="n">DATA_TO_INDEX_RATIO</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">VECTOR_SIZE</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">values_buffer</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">values0_f32</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="n">index_buffer</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx0</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="n">INDEX_BITS</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">VECTOR_SIZE</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">values_buffer</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">VECTOR_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="n">values1_f32</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="n">index_buffer</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">VECTOR_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx1</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="n">INDEX_BITS</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Directly decompress data stored in a packed variation of CSR.</span>
<span class="c1">//</span>
<span class="c1">// cmp_data: Compressed data, packed in groups of 16 x FP16 elements.</span>
<span class="c1">// cmp_col_idx: Relative 4-bit indices that indicate the number of zeros before</span>
<span class="c1">//              the next value in cmp_values in the same row.</span>
<span class="c1">// cmp_row_idx: Packed pair of values for each row in the matrix. The first 16</span>
<span class="c1">//              bits indicate the starting index of the ith row (by 256 bit</span>
<span class="c1">//              granularity), and the second 16 bits indicate the number of</span>
<span class="c1">//              nonzero values in this row.</span>
<span class="c1">// data_dims: The dimensions of the uncompressed data.</span>
<span class="c1">// dcmp_data: The base of the uncompressed data buffer.</span>
<span class="kt">void</span> <span class="nf">decompress_packed_csr_data</span><span class="p">(</span><span class="n">packed_fp16</span><span class="o">*</span> <span class="n">cmp_data</span><span class="p">,</span>
                                <span class="kt">uint32_t</span><span class="o">*</span> <span class="n">cmp_col_idx</span><span class="p">,</span>
                                <span class="kt">uint32_t</span><span class="o">*</span> <span class="n">cmp_row_idx</span><span class="p">,</span>
                                <span class="n">dims_t</span><span class="o">*</span> <span class="n">data_dims</span><span class="p">,</span>
                                <span class="kt">float</span><span class="o">*</span> <span class="n">dcmp_data</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">data_rows</span> <span class="o">=</span> <span class="n">data_dims</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">data_cols</span> <span class="o">=</span> <span class="n">data_dims</span><span class="o">-&gt;</span><span class="n">cols</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">data_pad</span> <span class="o">=</span> <span class="n">data_dims</span><span class="o">-&gt;</span><span class="n">align_pad</span><span class="p">;</span>

    <span class="n">ARRAY_2D</span><span class="p">(</span><span class="kt">float</span><span class="p">,</span> <span class="n">_data</span><span class="p">,</span> <span class="n">dcmp_data</span><span class="p">,</span> <span class="n">data_cols</span> <span class="o">+</span> <span class="n">data_pad</span><span class="p">);</span>
    <span class="n">PRINT_MSG_V</span><span class="p">(</span><span class="s">&quot;==== DECOMPRESSING ==== </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">data_rows</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Row indices are themselves packed into an index and the number of</span>
        <span class="c1">// nonzeros in that row, 16 bits each. The index indicates where the</span>
        <span class="c1">// first element of this row is stored in the compressed data (as a</span>
        <span class="c1">// 32-byte vector index). We also need the number of nonzeros stored</span>
        <span class="c1">// separately in order to properly handle the fact that separate rows</span>
        <span class="c1">// cannot cross vector (32-byte) boundaries.</span>
        <span class="kt">uint32_t</span> <span class="n">packed_idx_size</span> <span class="o">=</span> <span class="n">cmp_row_idx</span><span class="p">[</span><span class="n">row</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">curr_row_start_idx</span> <span class="o">=</span> <span class="n">get_row_idx</span><span class="p">(</span><span class="n">packed_idx_size</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">curr_row_size</span> <span class="o">=</span> <span class="n">get_row_size</span><span class="p">(</span><span class="n">packed_idx_size</span><span class="p">);</span>
        <span class="n">PRINT_MSG_V</span><span class="p">(</span><span class="s">&quot;Row %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">row</span><span class="p">);</span>
        <span class="n">PRINT_MSG_V</span><span class="p">(</span><span class="s">&quot;  Row start idx: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">curr_row_start_idx</span><span class="p">);</span>
        <span class="n">PRINT_MSG_V</span><span class="p">(</span><span class="s">&quot;  Row size: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">curr_row_size</span><span class="p">);</span>

        <span class="c1">// A column index of zero means there are no zeros in between these two</span>
        <span class="c1">// nonzero values. We therefore need to implicitly add 1 to the</span>
        <span class="c1">// existing offset to figure out where to put the new value, and this</span>
        <span class="c1">// boundary condition is easily handled with a starting offset of -1.</span>
        <span class="kt">int</span> <span class="n">col_idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">num_elems_remaining</span> <span class="o">=</span> <span class="n">curr_row_size</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">curr_row_size</span><span class="p">;</span> <span class="n">col</span> <span class="o">+=</span> <span class="n">DATA_PACKING_FACTOR</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">float</span> <span class="n">values_buffer</span><span class="p">[</span><span class="n">VECTOR_SIZE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">index_buffer</span><span class="p">[</span><span class="n">VECTOR_SIZE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">];</span>
            <span class="n">unpack_values_at_row</span><span class="p">(</span>
                    <span class="n">cmp_data</span><span class="p">,</span>
                    <span class="n">cmp_col_idx</span><span class="p">,</span>
                    <span class="n">curr_row_start_idx</span> <span class="o">+</span> <span class="p">(</span><span class="n">col</span> <span class="o">/</span> <span class="n">DATA_PACKING_FACTOR</span><span class="p">),</span>
                    <span class="n">values_buffer</span><span class="p">,</span>
                    <span class="n">index_buffer</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">DATA_PACKING_FACTOR</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">PRINT_MSG_V</span><span class="p">(</span><span class="s">&quot;  values_buffer[%d] = %f, index_buffer[%d] = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                            <span class="n">i</span><span class="p">,</span> <span class="n">values_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">,</span> <span class="n">index_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">min2</span><span class="p">(</span><span class="n">num_elems_remaining</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span> <span class="n">val</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">float</span> <span class="n">value</span> <span class="o">=</span> <span class="n">values_buffer</span><span class="p">[</span><span class="n">val</span><span class="p">];</span>
                <span class="c1">// Within each row, the column indices must be accumulated, as</span>
                <span class="c1">// they are relative positions, not absolute positions.</span>
                <span class="n">col_idx</span> <span class="o">+=</span> <span class="n">index_buffer</span><span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">ASSERT</span><span class="p">(</span><span class="n">col_idx</span> <span class="o">&lt;</span> <span class="n">data_cols</span> <span class="o">+</span> <span class="n">data_pad</span> <span class="o">&amp;&amp;</span>
                       <span class="s">&quot;Column index exceeds width of matrix!&quot;</span><span class="p">);</span>
                <span class="n">_data</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
                <span class="n">PRINT_MSG_V</span><span class="p">(</span>
                        <span class="s">&quot;  Storing _data[%d][%d] = %f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col_idx</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">num_elems_remaining</span> <span class="o">-=</span> <span class="mi">16</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//===--------------------------------------------==//</span>
<span class="c1">// Packed CSR array tiling functions.</span>
<span class="c1">//===--------------------------------------------==//</span>

<span class="n">csr_tile</span><span class="o">*</span> <span class="nf">init_csr_tile</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">csr_tile</span><span class="o">*</span> <span class="n">tile</span> <span class="o">=</span> <span class="p">(</span><span class="n">csr_tile</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">csr_tile</span><span class="p">));</span>
    <span class="n">tile</span><span class="o">-&gt;</span><span class="n">start_row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">tile</span><span class="o">-&gt;</span><span class="n">num_elems</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">tile</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">tile</span><span class="o">-&gt;</span><span class="n">num_vectors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">tile</span><span class="o">-&gt;</span><span class="n">total_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">tile</span><span class="o">-&gt;</span><span class="n">eff_total_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">tile</span><span class="o">-&gt;</span><span class="n">next_tile</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">tile</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">free_csr_tile_list</span><span class="p">(</span><span class="n">csr_tile_list</span><span class="o">*</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list</span> <span class="o">||</span> <span class="o">!</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">)</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="n">csr_tile</span><span class="o">*</span> <span class="n">head</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="n">csr_tile</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next_tile</span><span class="p">;</span>
        <span class="n">free_packed_csr_array_t</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">);</span>
        <span class="n">free</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">head</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Compute the required bytes to store this store.</span>
<span class="c1">//</span>
<span class="c1">// Args:</span>
<span class="c1">//    num_elems_in_row: Number of nonzeros (plus padding zeros) in this row.</span>
<span class="c1">//</span>
<span class="c1">// Results:</span>
<span class="c1">//    size_for_row: The total number of bytes required for this row, including</span>
<span class="c1">//       all indices.</span>
<span class="c1">//    num_vectors: The number of vectors required to store the packed data in</span>
<span class="c1">//       this row.</span>
<span class="kt">void</span> <span class="nf">compute_bytes_for_row_storage</span><span class="p">(</span><span class="kt">int</span> <span class="n">num_elems_in_row</span><span class="p">,</span>
                                   <span class="kt">size_t</span><span class="o">*</span> <span class="n">size_for_row</span><span class="p">,</span>
                                   <span class="kt">int</span><span class="o">*</span> <span class="n">num_vectors</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">num_data_vectors</span> <span class="o">=</span> <span class="n">compute_num_vectors_in_row</span><span class="p">(</span><span class="n">num_elems_in_row</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">data_bytes</span> <span class="o">=</span> <span class="n">num_data_vectors</span> <span class="o">*</span> <span class="n">TOTAL_VECTOR_BYTES</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">col_bytes</span> <span class="o">=</span> <span class="n">num_data_vectors</span> <span class="o">*</span> <span class="n">DATA_TO_INDEX_RATIO</span> <span class="o">*</span>
                    <span class="k">sizeof</span><span class="p">(</span><span class="n">IndexContainerType</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">row_bytes</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
    <span class="o">*</span><span class="n">size_for_row</span> <span class="o">=</span> <span class="n">data_bytes</span> <span class="o">+</span> <span class="n">col_bytes</span> <span class="o">+</span> <span class="n">row_bytes</span><span class="p">;</span>
    <span class="o">*</span><span class="n">num_vectors</span> <span class="o">=</span> <span class="n">num_data_vectors</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Determine how to tile a large CSR array in as few tiles as possible.</span>
<span class="c1">//</span>
<span class="c1">// This returns a list of CSR array tiles, which denote the dimensions of each</span>
<span class="c1">// tile and the required storage for the array. The number of tiles is</span>
<span class="c1">// determined by the sparsity of the original array. Tiles are returned as a</span>
<span class="c1">// linked-list.</span>
<span class="c1">//</span>
<span class="c1">// Args:</span>
<span class="c1">//   csr: The original CSR array.</span>
<span class="c1">//   starting_row: Begin tiling from this row in the original array.</span>
<span class="c1">//   num_rows: Tile up to this many rows from starting_row.</span>
<span class="c1">//   num_cols: The total number of columns in the decompressed array.</span>
<span class="c1">//   max_tile_size: The maximum compressed size of each tile.</span>
<span class="c1">//</span>
<span class="c1">// Returns:</span>
<span class="c1">//   A linked list of CSR tile dimensions.</span>
<span class="n">csr_tile_list</span><span class="o">*</span> <span class="nf">compute_tiled_packed_csr_array_dims</span><span class="p">(</span><span class="n">packed_csr_array_t</span><span class="o">*</span> <span class="n">csr</span><span class="p">,</span>
                                                   <span class="kt">int</span> <span class="n">starting_row</span><span class="p">,</span>
                                                   <span class="kt">int</span> <span class="n">num_rows</span><span class="p">,</span>
                                                   <span class="kt">int</span> <span class="n">num_cols</span><span class="p">,</span>
                                                   <span class="kt">size_t</span> <span class="n">max_tile_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">curr_row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">num_tiles</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">csr_tile</span><span class="o">*</span> <span class="n">head</span> <span class="o">=</span> <span class="n">init_csr_tile</span><span class="p">();</span>
    <span class="n">csr_tile</span><span class="o">*</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">curr</span><span class="o">-&gt;</span><span class="n">start_row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">curr_row</span> <span class="o">&lt;</span> <span class="n">num_rows</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">packed_row_size</span> <span class="o">=</span> <span class="n">csr</span><span class="o">-&gt;</span><span class="n">row_idx</span><span class="p">[</span><span class="n">starting_row</span> <span class="o">+</span> <span class="n">curr_row</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">num_elems</span> <span class="o">=</span> <span class="n">get_row_size</span><span class="p">(</span><span class="n">packed_row_size</span><span class="p">);</span>
        <span class="kt">size_t</span> <span class="n">size_for_row</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">num_vectors</span><span class="p">;</span>
        <span class="n">compute_bytes_for_row_storage</span><span class="p">(</span><span class="n">num_elems</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size_for_row</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_vectors</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">total_bytes</span> <span class="o">+</span> <span class="n">size_for_row</span> <span class="o">&gt;</span> <span class="n">max_tile_size</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Finish off the current tile.</span>
            <span class="n">curr</span><span class="o">-&gt;</span><span class="n">total_bytes</span> <span class="o">=</span>
                    <span class="n">next_multiple</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">total_bytes</span><span class="p">,</span> <span class="n">TOTAL_VECTOR_BYTES</span><span class="p">);</span>
            <span class="n">curr</span><span class="o">-&gt;</span><span class="n">eff_total_bytes</span> <span class="o">=</span>
                    <span class="n">next_multiple</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">*</span> <span class="n">num_cols</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span>
                                  <span class="n">TOTAL_VECTOR_BYTES</span><span class="p">);</span>

            <span class="c1">// Start the next tile. This code can be reused.</span>
            <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next_tile</span> <span class="o">=</span> <span class="n">init_csr_tile</span><span class="p">();</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next_tile</span><span class="p">;</span>
            <span class="n">curr</span><span class="o">-&gt;</span><span class="n">start_row</span> <span class="o">=</span> <span class="n">curr_row</span><span class="p">;</span>
            <span class="n">num_tiles</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// Now update the current tile.</span>
        <span class="n">curr</span><span class="o">-&gt;</span><span class="n">total_bytes</span> <span class="o">+=</span> <span class="n">size_for_row</span><span class="p">;</span>
        <span class="n">curr</span><span class="o">-&gt;</span><span class="n">num_rows</span><span class="o">++</span><span class="p">;</span>
        <span class="n">curr</span><span class="o">-&gt;</span><span class="n">num_elems</span> <span class="o">+=</span> <span class="n">num_elems</span><span class="p">;</span>
        <span class="n">curr</span><span class="o">-&gt;</span><span class="n">num_vectors</span> <span class="o">+=</span> <span class="n">num_vectors</span><span class="p">;</span>
        <span class="n">curr_row</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// Round the last tile size to vector alignment if necessary.</span>
    <span class="n">curr</span><span class="o">-&gt;</span><span class="n">total_bytes</span> <span class="o">=</span> <span class="n">next_multiple</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">total_bytes</span><span class="p">,</span> <span class="n">TOTAL_VECTOR_BYTES</span><span class="p">);</span>
    <span class="n">curr</span><span class="o">-&gt;</span><span class="n">eff_total_bytes</span> <span class="o">=</span> <span class="n">next_multiple</span><span class="p">(</span>
         <span class="n">curr</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">*</span> <span class="n">num_cols</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="n">TOTAL_VECTOR_BYTES</span><span class="p">);</span>

    <span class="n">csr_tile_list</span><span class="o">*</span> <span class="n">list</span> <span class="o">=</span> <span class="p">(</span><span class="n">csr_tile_list</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">csr_tile_list</span><span class="p">));</span>
    <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">list</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">num_tiles</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">list</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Tile a large CSR array.</span>
<span class="c1">//</span>
<span class="c1">// The result is a linked list of CSR tiles. Each tile contains metadata about</span>
<span class="c1">// the tile parameters (size, number of nonzeros, etc) as well as a</span>
<span class="c1">// packed_csr_array_t object that contains the data itself.</span>
<span class="c1">//</span>
<span class="c1">// Each tile&#39;s row indices start from 0, so if the original array looked like</span>
<span class="c1">// this, and there were two tiles:</span>
<span class="c1">//    Orig:</span>
<span class="c1">//       Row 0: [data, columns]</span>
<span class="c1">//       Row 1: [data, columns]</span>
<span class="c1">//       Row 2: [data, columns]</span>
<span class="c1">//       Row 3: [data, columns]</span>
<span class="c1">//       Row indices: [0, 1, 2, 3]</span>
<span class="c1">//    Tiled:</span>
<span class="c1">//       Row 0: [data, columns]</span>
<span class="c1">//       Row 1: [data, columns]</span>
<span class="c1">//       Row indices: [0, 1]</span>
<span class="c1">//       ----</span>
<span class="c1">//       Row 0: [data, columns]</span>
<span class="c1">//       Row 1: [data, columns]</span>
<span class="c1">//       Row indices: [0, 1]</span>
<span class="c1">//</span>
<span class="c1">// Args:</span>
<span class="c1">//   input: A pointer to the original, complete CSR array.</span>
<span class="c1">//   dims: The dimensions of the decompressed array.</span>
<span class="c1">//   starting_row: Begin tiling the array from this row.</span>
<span class="c1">//   max_tile_size: The maximum size in bytes of each tile.</span>
<span class="n">csr_tile_list</span><span class="o">*</span> <span class="nf">tile_packed_csr_array_t</span><span class="p">(</span><span class="n">packed_csr_array_t</span><span class="o">*</span> <span class="n">input</span><span class="p">,</span>
                                       <span class="n">dims_t</span><span class="o">*</span> <span class="n">dims</span><span class="p">,</span>
                                       <span class="kt">int</span> <span class="n">starting_row</span><span class="p">,</span>
                                       <span class="kt">size_t</span> <span class="n">max_tile_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// TODO: Add a special case to handle the case when no tiling is needed.</span>
    <span class="n">csr_tile_list</span><span class="o">*</span> <span class="n">list</span> <span class="o">=</span> <span class="n">compute_tiled_packed_csr_array_dims</span><span class="p">(</span>
            <span class="n">input</span><span class="p">,</span> <span class="n">starting_row</span><span class="p">,</span> <span class="n">dims</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">,</span> <span class="n">dims</span><span class="o">-&gt;</span><span class="n">cols</span><span class="p">,</span> <span class="n">max_tile_size</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">start_row</span> <span class="o">=</span> <span class="n">starting_row</span><span class="p">;</span>
    <span class="c1">// Compute the starting offsets into the value and col_idx arrays, based on</span>
    <span class="c1">// the starting row.</span>
    <span class="kt">int</span> <span class="n">packed_start_row_idx</span> <span class="o">=</span> <span class="n">get_row_idx</span><span class="p">(</span><span class="n">input</span><span class="o">-&gt;</span><span class="n">row_idx</span><span class="p">[</span><span class="n">start_row</span><span class="p">]);</span>
    <span class="kt">uint32_t</span> <span class="n">value_offset</span> <span class="o">=</span>
            <span class="n">packed_start_row_idx</span> <span class="o">*</span> <span class="p">(</span><span class="n">TOTAL_VECTOR_BYTES</span> <span class="o">/</span> <span class="n">UNPACKED_ELEMENT_SIZE</span><span class="p">);</span>
    <span class="kt">uint32_t</span> <span class="n">col_offset</span> <span class="o">=</span> <span class="n">packed_start_row_idx</span> <span class="o">*</span> <span class="n">DATA_TO_INDEX_RATIO</span><span class="p">;</span>
    <span class="n">csr_tile</span><span class="o">*</span> <span class="n">curr_tile</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">curr_tile</span><span class="o">-&gt;</span><span class="n">array</span> <span class="o">=</span> <span class="n">alloc_packed_csr_array_t</span><span class="p">(</span><span class="n">curr_tile</span><span class="o">-&gt;</span><span class="n">num_vectors</span><span class="p">,</span>
                                                    <span class="n">curr_tile</span><span class="o">-&gt;</span><span class="n">num_elems</span><span class="p">,</span>
                                                    <span class="n">curr_tile</span><span class="o">-&gt;</span><span class="n">num_rows</span><span class="p">);</span>
        <span class="c1">// Now copy the relevant regions of the value and column index buffers.</span>
        <span class="c1">// TODO: Unify this behavior with alloc_packed_csr_array_t!!</span>
        <span class="kt">size_t</span> <span class="n">value_bytes_to_copy</span> <span class="o">=</span>
                <span class="n">curr_tile</span><span class="o">-&gt;</span><span class="n">num_vectors</span> <span class="o">*</span> <span class="n">TOTAL_VECTOR_BYTES</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">col_bytes_to_copy</span> <span class="o">=</span>
                <span class="p">(</span><span class="n">curr_tile</span><span class="o">-&gt;</span><span class="n">num_vectors</span> <span class="o">*</span> <span class="n">DATA_TO_INDEX_RATIO</span><span class="p">)</span> <span class="o">*</span>
                <span class="k">sizeof</span><span class="p">(</span><span class="n">IndexContainerType</span><span class="p">);</span>

        <span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">curr_tile</span><span class="o">-&gt;</span><span class="n">array</span><span class="o">-&gt;</span><span class="n">vals</span><span class="p">,</span> <span class="n">input</span><span class="o">-&gt;</span><span class="n">vals</span> <span class="o">+</span> <span class="n">value_offset</span><span class="p">,</span>
               <span class="n">value_bytes_to_copy</span><span class="p">);</span>
        <span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">curr_tile</span><span class="o">-&gt;</span><span class="n">array</span><span class="o">-&gt;</span><span class="n">col_idx</span><span class="p">,</span> <span class="n">input</span><span class="o">-&gt;</span><span class="n">col_idx</span> <span class="o">+</span> <span class="n">col_offset</span><span class="p">,</span>
               <span class="n">col_bytes_to_copy</span><span class="p">);</span>
        <span class="c1">// The row indices need to start from zero for each tile.</span>
        <span class="kt">int</span> <span class="n">row_offset_reset</span> <span class="o">=</span> <span class="n">get_row_idx</span><span class="p">(</span><span class="n">input</span><span class="o">-&gt;</span><span class="n">row_idx</span><span class="p">[</span><span class="n">start_row</span><span class="p">]);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">curr_tile</span><span class="o">-&gt;</span><span class="n">num_rows</span><span class="p">;</span> <span class="n">r</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">uint32_t</span> <span class="n">packed_idx_size</span> <span class="o">=</span> <span class="n">input</span><span class="o">-&gt;</span><span class="n">row_idx</span><span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="n">start_row</span><span class="p">];</span>
            <span class="kt">uint32_t</span> <span class="n">row_offset</span> <span class="o">=</span> <span class="n">get_row_idx</span><span class="p">(</span><span class="n">packed_idx_size</span><span class="p">);</span>
            <span class="kt">uint32_t</span> <span class="n">num_elems</span> <span class="o">=</span> <span class="n">get_row_size</span><span class="p">(</span><span class="n">packed_idx_size</span><span class="p">);</span>
            <span class="n">curr_tile</span><span class="o">-&gt;</span><span class="n">array</span><span class="o">-&gt;</span><span class="n">row_idx</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span>
                    <span class="n">create_packed_row</span><span class="p">(</span><span class="n">row_offset</span> <span class="o">-</span> <span class="n">row_offset_reset</span><span class="p">,</span> <span class="n">num_elems</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// The offset into the value array needs to be calculated with respect</span>
        <span class="c1">// to the type used in packed_csr_array_t (uint32_t*) while taking into</span>
        <span class="c1">// account the fact that values are packed into 32-byte vectors.</span>
        <span class="n">value_offset</span> <span class="o">+=</span>
                <span class="n">curr_tile</span><span class="o">-&gt;</span><span class="n">num_vectors</span> <span class="o">*</span> <span class="n">TOTAL_VECTOR_BYTES</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
        <span class="c1">// TODO: The offset into the value array is calculated as an 32-bit</span>
        <span class="c1">// integer offset but it should be calculated as a vector offset.</span>
        <span class="n">col_offset</span> <span class="o">+=</span> <span class="n">curr_tile</span><span class="o">-&gt;</span><span class="n">num_vectors</span> <span class="o">*</span> <span class="n">DATA_TO_INDEX_RATIO</span><span class="p">;</span>

        <span class="n">start_row</span> <span class="o">+=</span> <span class="n">curr_tile</span><span class="o">-&gt;</span><span class="n">num_rows</span><span class="p">;</span>
        <span class="n">curr_tile</span> <span class="o">=</span> <span class="n">curr_tile</span><span class="o">-&gt;</span><span class="n">next_tile</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">list</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, SMAUG Contributors

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>